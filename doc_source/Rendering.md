Rendering {#rendering}
===========

## Feeding the GPU

The vertices and indices available through the *Voxels::PolygonSurface* object must be uploaded to the graphics API. **Voxels** is 
graphics API agnostic, so the client is in charge of uploading data to the GPU and drawing it.

## Rendering with LOD

After polygonization **Voxels** outputs a set of *blocks* in LOD levels. LOD level 0 is the most detailed with each subsequent 
level having half the detail of the previous. The number of blocks in the levels is also different and blocks in a coarser level have twice the 
physical size on every axis of blocks in a more detailed one. For instance in a block of level 1 fit 8 blocks of level 0.

To save GPU resources we would like to draw blocks with high level of detail near the virtual camera in the scene and coarser blocks in the distance.
The client application has to implement a culling mechanism and an algorithm that makes use of the LOD levels to maximise performance but preserve
the visual quality of the surface.

A sample implementation of a class that selects LOD blocks on runtime named **VoxelLodOctree** is provided in the samples. It builds on octree from the
output blocks and on each frame it decides which blocks to draw depending on the camera position in the world. It also does frustum culling so blocks that are 
not seen by the camera are not drawn.

**Note:** You should never have blocks that differ more than 1 LOD level drawn as neighbours, otherwise cracks may appear.

## Transition meshes

When two blocks of different LOD level are rendered next to each other, cracks might appear between them. This happens because the blocks 
represent different approximations of the underlying surface. The TransVoxel algorithm and its **Voxels** implementation fix this by introducing 
*transition meshes* between levels. 

Each block of LOD level > 0 has up to 6 (because a cube has 6 sides) transition meshes associated with it. Upon drawing if a block of level > 0 has a direct 
neighbour of a finer level you must draw the transition mesh for the face they share. The transition mesh will fill the eventual cracks that otherwise 
will generate visual artefacts.

Transition meshes are generated only for combinations of blocks that differ of LOD by one level. That means that if block of level 3 is next to one of 
level 2, you must draw the transition of the level 3 block for the face it shared with the level 2 one. However to keep computations and combinations fast 
there are no transition cells generated for LOD differences > 2. You should never allow for blocks with LOD difference > 2 to be drawn 
next to each other, cracks will appear if you do.

When drawing next to each other blocks with the same level they can be drawn normally. When drawing a block with any transition however, care should be taken. 
All vertices on the boundary between the levels must be "moved back" a little in order to leave space for the transition mesh and prevent z-fighting. 
For every block a secondary set of vertices is generated by **Voxels**. In the W component of the secondary vertex a special mask value is saved 
that helps selecting either the primary or secondary vertex in the vertex shader.

For DirectX this can be accomplished with the following code in the vertex shader:

~~~~~~~~~~{.cpp}
float4 SelectPositionCell(int vertexAdj, int blockAdj, float4 primary, float4 secondary) {
	if(vertexAdj && ((vertexAdj & blockAdj) == vertexAdj)) {
		return float4(secondary.xyz, 1);
	} else {
		return primary;		
	}
}
~~~~~~~~~~

In this code *vertexAdj* is the *w* component of the *SecondaryVertex* of the block. The *blockAdj* is a uniform constant passed by the application 
for each block with information which transitions are drawn this frame for this block.

For more information and sample usage please refer to the example applications accompanying **Voxels**.

## Texturing

Surfaces generated by **Voxels** are designed to be textured via triplanar texturing. Please refer to the *Materials* section for more details.
